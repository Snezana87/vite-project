import { makeRe, scan } from 'micromatch';
import deprecate from 'util-deprecate';
import dedent from 'ts-dedent';
import path from 'path'; // LEGACY support for bad glob patterns we had in SB 5 - remove in SB7

var fixBadGlob = deprecate(function (match) {
  return match.input.replace(match[1], `@${match[1]}`);
}, dedent`
    You have specified an invalid glob, we've attempted to fix it, please ensure that the glob you specify is valid. See: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#correct-globs-in-mainjs
  `);

var detectBadGlob = function (val) {
  var match = val.match(/\.(\([^)]+\))/);

  if (match) {
    return fixBadGlob(match);
  }

  return val;
};

var isObject = function (val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

export var toRequireContext = function (input) {
  var fixedInput = detectBadGlob(input);

  switch (true) {
    case typeof input === 'string':
      {
        var globResult = scan(fixedInput);
        var base = globResult.isGlob ? globResult.prefix + globResult.base : path.dirname(fixedInput);
        var globFallback = base !== '.' ? fixedInput.substr(base.length + 1) : fixedInput;
        var glob = globResult.isGlob ? globResult.glob : globFallback;
        var regex = makeRe(glob, {
          fastpaths: false,
          noglobstar: false,
          bash: false
        });
        var source = regex.source;

        if (source.startsWith('^')) {
          // webpack's require.context matches against paths starting `./`
          // Globs starting `**` require special treatment due to the regex they
          // produce, specifically a negative look-ahead
          var match = ['^\\.', glob.startsWith('**') ? '' : '\\/', source.substring(1)].join('');
          var recursive = glob.includes('**') || glob.split('/').length > 1;
          return {
            path: base,
            recursive: recursive,
            match: match
          };
        }

        throw new Error(`Invalid glob: >> ${input} >> ${regex}`);
      }

    case isObject(input):
      {
        return input;
      }

    default:
      {
        throw new Error('the provided input cannot be transformed into a require.context');
      }
  }
};
export var toRequireContextString = function (input) {
  var _toRequireContext = toRequireContext(input),
      p = _toRequireContext.path,
      r = _toRequireContext.recursive,
      m = _toRequireContext.match;

  var result = `require.context('${p}', ${r}, /${m}/)`;
  return result;
};